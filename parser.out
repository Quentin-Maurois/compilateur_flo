Grammar:

Rule 0     S' -> prog
Rule 1     prog -> listeSinonsi
Rule 2     prog -> listeInstructions
Rule 3     listeInstructions -> instruction listeInstructions
Rule 4     listeInstructions -> instruction
Rule 5     listeSinonsi -> SINON_SI listeSinonsi
Rule 6     listeSinonsi -> SINON_SI
Rule 7     instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ;
Rule 8     instruction -> TYPE_ENTIER IDENTIFIANT = expr ;
Rule 9     instruction -> IDENTIFIANT = expr ;
Rule 10    instruction -> TYPE_BOOLEEN IDENTIFIANT ;
Rule 11    instruction -> TYPE_ENTIER IDENTIFIANT ;
Rule 12    instruction -> TANT_QUE ( expr ) { listeInstructions }
Rule 13    instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
Rule 14    instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions }
Rule 15    instruction -> SI ( expr ) { listeInstructions } SINON_SI
Rule 16    instruction -> SI ( expr ) { listeInstructions }
Rule 17    instruction -> IDENTIFIANT = LIRE ( ) ;
Rule 18    instruction -> ecrire
Rule 19    ecrire -> ECRIRE ( expr ) ;
Rule 20    expr -> FAUX
Rule 21    expr -> VRAI
Rule 22    expr -> NON expr  [precedence=right, level=2]
Rule 23    expr -> expr OU expr  [precedence=left, level=1]
Rule 24    expr -> expr ET expr  [precedence=left, level=1]
Rule 25    expr -> expr DIFFERENT expr  [precedence=left, level=3]
Rule 26    expr -> expr EGAL expr  [precedence=left, level=3]
Rule 27    expr -> expr SUPERIEUR_OU_EGAL expr  [precedence=left, level=3]
Rule 28    expr -> expr INFERIEUR_OU_EGAL expr  [precedence=left, level=3]
Rule 29    expr -> expr SUPERIEUR expr  [precedence=left, level=3]
Rule 30    expr -> expr INFERIEUR expr  [precedence=left, level=3]
Rule 31    expr -> ENTIER
Rule 32    expr -> ( expr )  [precedence=left, level=6]
Rule 33    expr -> expr % expr  [precedence=left, level=5]
Rule 34    expr -> expr / expr  [precedence=left, level=5]
Rule 35    expr -> expr * expr  [precedence=left, level=5]
Rule 36    expr -> expr - expr  [precedence=left, level=4]
Rule 37    expr -> expr + expr  [precedence=left, level=4]

Unused terminals:

    ==
    RETOURNER
    ACCOLADE_FERMANTE
    ACCOLADE_OUVRANTE
    <=
    !=
    POINT_VIRGULE
    VIRGULE
    PARENTHESE_FERMANTE
    <
    >
    ,
    >=
    PARENTHESE_OUVRANTE

Terminals, with rules where they appear:

!=                   : 
%                    : 33
(                    : 12 13 14 15 16 17 19 32
)                    : 12 13 14 15 16 17 19 32
*                    : 35
+                    : 37
,                    : 
-                    : 36
/                    : 34
;                    : 7 8 9 10 11 17 19
<                    : 
<=                   : 
=                    : 7 8 9 17
==                   : 
>                    : 
>=                   : 
ACCOLADE_FERMANTE    : 
ACCOLADE_OUVRANTE    : 
DIFFERENT            : 25
ECRIRE               : 19
EGAL                 : 26
ENTIER               : 31
ET                   : 24
FAUX                 : 20
IDENTIFIANT          : 7 8 9 10 11 17
INFERIEUR            : 30
INFERIEUR_OU_EGAL    : 28
LIRE                 : 17
NON                  : 22
OU                   : 23
PARENTHESE_FERMANTE  : 
PARENTHESE_OUVRANTE  : 
POINT_VIRGULE        : 
RETOURNER            : 
SI                   : 13 14 15 16
SINON                : 13 14
SINON_SI             : 5 6 13 15
SUPERIEUR            : 29
SUPERIEUR_OU_EGAL    : 27
TANT_QUE             : 12
TYPE_BOOLEEN         : 7 10
TYPE_ENTIER          : 8 11
VIRGULE              : 
VRAI                 : 21
error                : 
{                    : 12 13 13 14 14 15 16
}                    : 12 13 13 14 14 15 16

Nonterminals, with rules where they appear:

ecrire               : 18
expr                 : 7 8 9 12 13 14 15 16 19 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 32 33 33 34 34 35 35 36 36 37 37
instruction          : 3 4
listeInstructions    : 2 3 12 13 13 14 14 15 16
listeSinonsi         : 1 5
prog                 : 0


state 0

    (0) S' -> . prog
    (1) prog -> . listeSinonsi
    (2) prog -> . listeInstructions
    (5) listeSinonsi -> . SINON_SI listeSinonsi
    (6) listeSinonsi -> . SINON_SI
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . TANT_QUE ( expr ) { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (15) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (16) instruction -> . SI ( expr ) { listeInstructions }
    (17) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (18) instruction -> . ecrire
    (19) ecrire -> . ECRIRE ( expr ) ;
    SINON_SI        shift and go to state 4
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    TANT_QUE        shift and go to state 9
    SI              shift and go to state 10
    ECRIRE          shift and go to state 12

    prog                           shift and go to state 1
    listeSinonsi                   shift and go to state 2
    listeInstructions              shift and go to state 3
    instruction                    shift and go to state 5
    ecrire                         shift and go to state 11

state 1

    (0) S' -> prog .


state 2

    (1) prog -> listeSinonsi .
    $end            reduce using rule 1 (prog -> listeSinonsi .)


state 3

    (2) prog -> listeInstructions .
    $end            reduce using rule 2 (prog -> listeInstructions .)


state 4

    (5) listeSinonsi -> SINON_SI . listeSinonsi
    (6) listeSinonsi -> SINON_SI .
    (5) listeSinonsi -> . SINON_SI listeSinonsi
    (6) listeSinonsi -> . SINON_SI
    $end            reduce using rule 6 (listeSinonsi -> SINON_SI .)
    SINON_SI        shift and go to state 4

    listeSinonsi                   shift and go to state 13

state 5

    (3) listeInstructions -> instruction . listeInstructions
    (4) listeInstructions -> instruction .
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . TANT_QUE ( expr ) { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (15) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (16) instruction -> . SI ( expr ) { listeInstructions }
    (17) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (18) instruction -> . ecrire
    (19) ecrire -> . ECRIRE ( expr ) ;
    $end            reduce using rule 4 (listeInstructions -> instruction .)
    }               reduce using rule 4 (listeInstructions -> instruction .)
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    TANT_QUE        shift and go to state 9
    SI              shift and go to state 10
    ECRIRE          shift and go to state 12

    instruction                    shift and go to state 5
    listeInstructions              shift and go to state 14
    ecrire                         shift and go to state 11

state 6

    (7) instruction -> TYPE_BOOLEEN . IDENTIFIANT = expr ;
    (10) instruction -> TYPE_BOOLEEN . IDENTIFIANT ;
    IDENTIFIANT     shift and go to state 15


state 7

    (9) instruction -> IDENTIFIANT . = expr ;
    (17) instruction -> IDENTIFIANT . = LIRE ( ) ;
    =               shift and go to state 16


state 8

    (8) instruction -> TYPE_ENTIER . IDENTIFIANT = expr ;
    (11) instruction -> TYPE_ENTIER . IDENTIFIANT ;
    IDENTIFIANT     shift and go to state 17


state 9

    (12) instruction -> TANT_QUE . ( expr ) { listeInstructions }
    (               shift and go to state 18


state 10

    (13) instruction -> SI . ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> SI . ( expr ) { listeInstructions } SINON { listeInstructions }
    (15) instruction -> SI . ( expr ) { listeInstructions } SINON_SI
    (16) instruction -> SI . ( expr ) { listeInstructions }
    (               shift and go to state 19


state 11

    (18) instruction -> ecrire .
    TYPE_BOOLEEN    reduce using rule 18 (instruction -> ecrire .)
    TYPE_ENTIER     reduce using rule 18 (instruction -> ecrire .)
    IDENTIFIANT     reduce using rule 18 (instruction -> ecrire .)
    TANT_QUE        reduce using rule 18 (instruction -> ecrire .)
    SI              reduce using rule 18 (instruction -> ecrire .)
    ECRIRE          reduce using rule 18 (instruction -> ecrire .)
    $end            reduce using rule 18 (instruction -> ecrire .)
    }               reduce using rule 18 (instruction -> ecrire .)


state 12

    (19) ecrire -> ECRIRE . ( expr ) ;
    (               shift and go to state 20


state 13

    (5) listeSinonsi -> SINON_SI listeSinonsi .
    $end            reduce using rule 5 (listeSinonsi -> SINON_SI listeSinonsi .)


state 14

    (3) listeInstructions -> instruction listeInstructions .
    $end            reduce using rule 3 (listeInstructions -> instruction listeInstructions .)
    }               reduce using rule 3 (listeInstructions -> instruction listeInstructions .)


state 15

    (7) instruction -> TYPE_BOOLEEN IDENTIFIANT . = expr ;
    (10) instruction -> TYPE_BOOLEEN IDENTIFIANT . ;
    =               shift and go to state 21
    ;               shift and go to state 22


state 16

    (9) instruction -> IDENTIFIANT = . expr ;
    (17) instruction -> IDENTIFIANT = . LIRE ( ) ;
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    LIRE            shift and go to state 24
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 23

state 17

    (8) instruction -> TYPE_ENTIER IDENTIFIANT . = expr ;
    (11) instruction -> TYPE_ENTIER IDENTIFIANT . ;
    =               shift and go to state 30
    ;               shift and go to state 31


state 18

    (12) instruction -> TANT_QUE ( . expr ) { listeInstructions }
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 32

state 19

    (13) instruction -> SI ( . expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> SI ( . expr ) { listeInstructions } SINON { listeInstructions }
    (15) instruction -> SI ( . expr ) { listeInstructions } SINON_SI
    (16) instruction -> SI ( . expr ) { listeInstructions }
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 33

state 20

    (19) ecrire -> ECRIRE ( . expr ) ;
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 34

state 21

    (7) instruction -> TYPE_BOOLEEN IDENTIFIANT = . expr ;
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 35

state 22

    (10) instruction -> TYPE_BOOLEEN IDENTIFIANT ; .
    TYPE_BOOLEEN    reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    TYPE_ENTIER     reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    IDENTIFIANT     reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    TANT_QUE        reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    SI              reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    ECRIRE          reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    $end            reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    }               reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)


state 23

    (9) instruction -> IDENTIFIANT = expr . ;
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               shift and go to state 36
    OU              shift and go to state 37
    ET              shift and go to state 38
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 24

    (17) instruction -> IDENTIFIANT = LIRE . ( ) ;
    (               shift and go to state 50


state 25

    (32) expr -> ( . expr )
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 51

state 26

    (20) expr -> FAUX .
    ;               reduce using rule 20 (expr -> FAUX .)
    OU              reduce using rule 20 (expr -> FAUX .)
    ET              reduce using rule 20 (expr -> FAUX .)
    DIFFERENT       reduce using rule 20 (expr -> FAUX .)
    EGAL            reduce using rule 20 (expr -> FAUX .)
    SUPERIEUR_OU_EGAL reduce using rule 20 (expr -> FAUX .)
    INFERIEUR_OU_EGAL reduce using rule 20 (expr -> FAUX .)
    SUPERIEUR       reduce using rule 20 (expr -> FAUX .)
    INFERIEUR       reduce using rule 20 (expr -> FAUX .)
    %               reduce using rule 20 (expr -> FAUX .)
    /               reduce using rule 20 (expr -> FAUX .)
    *               reduce using rule 20 (expr -> FAUX .)
    -               reduce using rule 20 (expr -> FAUX .)
    +               reduce using rule 20 (expr -> FAUX .)
    )               reduce using rule 20 (expr -> FAUX .)


state 27

    (21) expr -> VRAI .
    ;               reduce using rule 21 (expr -> VRAI .)
    OU              reduce using rule 21 (expr -> VRAI .)
    ET              reduce using rule 21 (expr -> VRAI .)
    DIFFERENT       reduce using rule 21 (expr -> VRAI .)
    EGAL            reduce using rule 21 (expr -> VRAI .)
    SUPERIEUR_OU_EGAL reduce using rule 21 (expr -> VRAI .)
    INFERIEUR_OU_EGAL reduce using rule 21 (expr -> VRAI .)
    SUPERIEUR       reduce using rule 21 (expr -> VRAI .)
    INFERIEUR       reduce using rule 21 (expr -> VRAI .)
    %               reduce using rule 21 (expr -> VRAI .)
    /               reduce using rule 21 (expr -> VRAI .)
    *               reduce using rule 21 (expr -> VRAI .)
    -               reduce using rule 21 (expr -> VRAI .)
    +               reduce using rule 21 (expr -> VRAI .)
    )               reduce using rule 21 (expr -> VRAI .)


state 28

    (22) expr -> NON . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 52

state 29

    (31) expr -> ENTIER .
    ;               reduce using rule 31 (expr -> ENTIER .)
    OU              reduce using rule 31 (expr -> ENTIER .)
    ET              reduce using rule 31 (expr -> ENTIER .)
    DIFFERENT       reduce using rule 31 (expr -> ENTIER .)
    EGAL            reduce using rule 31 (expr -> ENTIER .)
    SUPERIEUR_OU_EGAL reduce using rule 31 (expr -> ENTIER .)
    INFERIEUR_OU_EGAL reduce using rule 31 (expr -> ENTIER .)
    SUPERIEUR       reduce using rule 31 (expr -> ENTIER .)
    INFERIEUR       reduce using rule 31 (expr -> ENTIER .)
    %               reduce using rule 31 (expr -> ENTIER .)
    /               reduce using rule 31 (expr -> ENTIER .)
    *               reduce using rule 31 (expr -> ENTIER .)
    -               reduce using rule 31 (expr -> ENTIER .)
    +               reduce using rule 31 (expr -> ENTIER .)
    )               reduce using rule 31 (expr -> ENTIER .)


state 30

    (8) instruction -> TYPE_ENTIER IDENTIFIANT = . expr ;
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 53

state 31

    (11) instruction -> TYPE_ENTIER IDENTIFIANT ; .
    TYPE_BOOLEEN    reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    TYPE_ENTIER     reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    IDENTIFIANT     reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    TANT_QUE        reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    SI              reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    ECRIRE          reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    $end            reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    }               reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)


state 32

    (12) instruction -> TANT_QUE ( expr . ) { listeInstructions }
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    )               shift and go to state 54
    OU              shift and go to state 37
    ET              shift and go to state 38
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 33

    (13) instruction -> SI ( expr . ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> SI ( expr . ) { listeInstructions } SINON { listeInstructions }
    (15) instruction -> SI ( expr . ) { listeInstructions } SINON_SI
    (16) instruction -> SI ( expr . ) { listeInstructions }
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    )               shift and go to state 55
    OU              shift and go to state 37
    ET              shift and go to state 38
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 34

    (19) ecrire -> ECRIRE ( expr . ) ;
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    )               shift and go to state 56
    OU              shift and go to state 37
    ET              shift and go to state 38
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 35

    (7) instruction -> TYPE_BOOLEEN IDENTIFIANT = expr . ;
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               shift and go to state 57
    OU              shift and go to state 37
    ET              shift and go to state 38
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 36

    (9) instruction -> IDENTIFIANT = expr ; .
    TYPE_BOOLEEN    reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    TYPE_ENTIER     reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    TANT_QUE        reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    SI              reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    $end            reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    }               reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)


state 37

    (23) expr -> expr OU . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 58

state 38

    (24) expr -> expr ET . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 59

state 39

    (25) expr -> expr DIFFERENT . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 60

state 40

    (26) expr -> expr EGAL . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 61

state 41

    (27) expr -> expr SUPERIEUR_OU_EGAL . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 62

state 42

    (28) expr -> expr INFERIEUR_OU_EGAL . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 63

state 43

    (29) expr -> expr SUPERIEUR . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 64

state 44

    (30) expr -> expr INFERIEUR . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 65

state 45

    (33) expr -> expr % . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 66

state 46

    (34) expr -> expr / . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 67

state 47

    (35) expr -> expr * . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 68

state 48

    (36) expr -> expr - . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 69

state 49

    (37) expr -> expr + . expr
    (20) expr -> . FAUX
    (21) expr -> . VRAI
    (22) expr -> . NON expr
    (23) expr -> . expr OU expr
    (24) expr -> . expr ET expr
    (25) expr -> . expr DIFFERENT expr
    (26) expr -> . expr EGAL expr
    (27) expr -> . expr SUPERIEUR_OU_EGAL expr
    (28) expr -> . expr INFERIEUR_OU_EGAL expr
    (29) expr -> . expr SUPERIEUR expr
    (30) expr -> . expr INFERIEUR expr
    (31) expr -> . ENTIER
    (32) expr -> . ( expr )
    (33) expr -> . expr % expr
    (34) expr -> . expr / expr
    (35) expr -> . expr * expr
    (36) expr -> . expr - expr
    (37) expr -> . expr + expr
    FAUX            shift and go to state 26
    VRAI            shift and go to state 27
    NON             shift and go to state 28
    ENTIER          shift and go to state 29
    (               shift and go to state 25

    expr                           shift and go to state 70

state 50

    (17) instruction -> IDENTIFIANT = LIRE ( . ) ;
    )               shift and go to state 71


state 51

    (32) expr -> ( expr . )
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    )               shift and go to state 72
    OU              shift and go to state 37
    ET              shift and go to state 38
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 52

    (22) expr -> NON expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 22 (expr -> NON expr .)
    OU              reduce using rule 22 (expr -> NON expr .)
    ET              reduce using rule 22 (expr -> NON expr .)
    )               reduce using rule 22 (expr -> NON expr .)
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 53

    (8) instruction -> TYPE_ENTIER IDENTIFIANT = expr . ;
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               shift and go to state 73
    OU              shift and go to state 37
    ET              shift and go to state 38
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 54

    (12) instruction -> TANT_QUE ( expr ) . { listeInstructions }
    {               shift and go to state 74


state 55

    (13) instruction -> SI ( expr ) . { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> SI ( expr ) . { listeInstructions } SINON { listeInstructions }
    (15) instruction -> SI ( expr ) . { listeInstructions } SINON_SI
    (16) instruction -> SI ( expr ) . { listeInstructions }
    {               shift and go to state 75


state 56

    (19) ecrire -> ECRIRE ( expr ) . ;
    ;               shift and go to state 76


state 57

    (7) instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .
    TYPE_BOOLEEN    reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    TYPE_ENTIER     reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    TANT_QUE        reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    SI              reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    $end            reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    }               reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)


state 58

    (23) expr -> expr OU expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 23 (expr -> expr OU expr .)
    OU              reduce using rule 23 (expr -> expr OU expr .)
    ET              reduce using rule 23 (expr -> expr OU expr .)
    )               reduce using rule 23 (expr -> expr OU expr .)
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 59

    (24) expr -> expr ET expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 24 (expr -> expr ET expr .)
    OU              reduce using rule 24 (expr -> expr ET expr .)
    ET              reduce using rule 24 (expr -> expr ET expr .)
    )               reduce using rule 24 (expr -> expr ET expr .)
    DIFFERENT       shift and go to state 39
    EGAL            shift and go to state 40
    SUPERIEUR_OU_EGAL shift and go to state 41
    INFERIEUR_OU_EGAL shift and go to state 42
    SUPERIEUR       shift and go to state 43
    INFERIEUR       shift and go to state 44
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 60

    (25) expr -> expr DIFFERENT expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 25 (expr -> expr DIFFERENT expr .)
    OU              reduce using rule 25 (expr -> expr DIFFERENT expr .)
    ET              reduce using rule 25 (expr -> expr DIFFERENT expr .)
    DIFFERENT       reduce using rule 25 (expr -> expr DIFFERENT expr .)
    EGAL            reduce using rule 25 (expr -> expr DIFFERENT expr .)
    SUPERIEUR_OU_EGAL reduce using rule 25 (expr -> expr DIFFERENT expr .)
    INFERIEUR_OU_EGAL reduce using rule 25 (expr -> expr DIFFERENT expr .)
    SUPERIEUR       reduce using rule 25 (expr -> expr DIFFERENT expr .)
    INFERIEUR       reduce using rule 25 (expr -> expr DIFFERENT expr .)
    )               reduce using rule 25 (expr -> expr DIFFERENT expr .)
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 61

    (26) expr -> expr EGAL expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 26 (expr -> expr EGAL expr .)
    OU              reduce using rule 26 (expr -> expr EGAL expr .)
    ET              reduce using rule 26 (expr -> expr EGAL expr .)
    DIFFERENT       reduce using rule 26 (expr -> expr EGAL expr .)
    EGAL            reduce using rule 26 (expr -> expr EGAL expr .)
    SUPERIEUR_OU_EGAL reduce using rule 26 (expr -> expr EGAL expr .)
    INFERIEUR_OU_EGAL reduce using rule 26 (expr -> expr EGAL expr .)
    SUPERIEUR       reduce using rule 26 (expr -> expr EGAL expr .)
    INFERIEUR       reduce using rule 26 (expr -> expr EGAL expr .)
    )               reduce using rule 26 (expr -> expr EGAL expr .)
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 62

    (27) expr -> expr SUPERIEUR_OU_EGAL expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    OU              reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    ET              reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    DIFFERENT       reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    EGAL            reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    SUPERIEUR_OU_EGAL reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    INFERIEUR_OU_EGAL reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    SUPERIEUR       reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    INFERIEUR       reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    )               reduce using rule 27 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 63

    (28) expr -> expr INFERIEUR_OU_EGAL expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    OU              reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    ET              reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    DIFFERENT       reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    EGAL            reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    SUPERIEUR_OU_EGAL reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    INFERIEUR_OU_EGAL reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    SUPERIEUR       reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    INFERIEUR       reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    )               reduce using rule 28 (expr -> expr INFERIEUR_OU_EGAL expr .)
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 64

    (29) expr -> expr SUPERIEUR expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    OU              reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    ET              reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    DIFFERENT       reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    EGAL            reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    SUPERIEUR_OU_EGAL reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    INFERIEUR_OU_EGAL reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    SUPERIEUR       reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    INFERIEUR       reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    )               reduce using rule 29 (expr -> expr SUPERIEUR expr .)
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 65

    (30) expr -> expr INFERIEUR expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 30 (expr -> expr INFERIEUR expr .)
    OU              reduce using rule 30 (expr -> expr INFERIEUR expr .)
    ET              reduce using rule 30 (expr -> expr INFERIEUR expr .)
    DIFFERENT       reduce using rule 30 (expr -> expr INFERIEUR expr .)
    EGAL            reduce using rule 30 (expr -> expr INFERIEUR expr .)
    SUPERIEUR_OU_EGAL reduce using rule 30 (expr -> expr INFERIEUR expr .)
    INFERIEUR_OU_EGAL reduce using rule 30 (expr -> expr INFERIEUR expr .)
    SUPERIEUR       reduce using rule 30 (expr -> expr INFERIEUR expr .)
    INFERIEUR       reduce using rule 30 (expr -> expr INFERIEUR expr .)
    )               reduce using rule 30 (expr -> expr INFERIEUR expr .)
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47
    -               shift and go to state 48
    +               shift and go to state 49


state 66

    (33) expr -> expr % expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 33 (expr -> expr % expr .)
    OU              reduce using rule 33 (expr -> expr % expr .)
    ET              reduce using rule 33 (expr -> expr % expr .)
    DIFFERENT       reduce using rule 33 (expr -> expr % expr .)
    EGAL            reduce using rule 33 (expr -> expr % expr .)
    SUPERIEUR_OU_EGAL reduce using rule 33 (expr -> expr % expr .)
    INFERIEUR_OU_EGAL reduce using rule 33 (expr -> expr % expr .)
    SUPERIEUR       reduce using rule 33 (expr -> expr % expr .)
    INFERIEUR       reduce using rule 33 (expr -> expr % expr .)
    %               reduce using rule 33 (expr -> expr % expr .)
    /               reduce using rule 33 (expr -> expr % expr .)
    *               reduce using rule 33 (expr -> expr % expr .)
    -               reduce using rule 33 (expr -> expr % expr .)
    +               reduce using rule 33 (expr -> expr % expr .)
    )               reduce using rule 33 (expr -> expr % expr .)


state 67

    (34) expr -> expr / expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 34 (expr -> expr / expr .)
    OU              reduce using rule 34 (expr -> expr / expr .)
    ET              reduce using rule 34 (expr -> expr / expr .)
    DIFFERENT       reduce using rule 34 (expr -> expr / expr .)
    EGAL            reduce using rule 34 (expr -> expr / expr .)
    SUPERIEUR_OU_EGAL reduce using rule 34 (expr -> expr / expr .)
    INFERIEUR_OU_EGAL reduce using rule 34 (expr -> expr / expr .)
    SUPERIEUR       reduce using rule 34 (expr -> expr / expr .)
    INFERIEUR       reduce using rule 34 (expr -> expr / expr .)
    %               reduce using rule 34 (expr -> expr / expr .)
    /               reduce using rule 34 (expr -> expr / expr .)
    *               reduce using rule 34 (expr -> expr / expr .)
    -               reduce using rule 34 (expr -> expr / expr .)
    +               reduce using rule 34 (expr -> expr / expr .)
    )               reduce using rule 34 (expr -> expr / expr .)


state 68

    (35) expr -> expr * expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 35 (expr -> expr * expr .)
    OU              reduce using rule 35 (expr -> expr * expr .)
    ET              reduce using rule 35 (expr -> expr * expr .)
    DIFFERENT       reduce using rule 35 (expr -> expr * expr .)
    EGAL            reduce using rule 35 (expr -> expr * expr .)
    SUPERIEUR_OU_EGAL reduce using rule 35 (expr -> expr * expr .)
    INFERIEUR_OU_EGAL reduce using rule 35 (expr -> expr * expr .)
    SUPERIEUR       reduce using rule 35 (expr -> expr * expr .)
    INFERIEUR       reduce using rule 35 (expr -> expr * expr .)
    %               reduce using rule 35 (expr -> expr * expr .)
    /               reduce using rule 35 (expr -> expr * expr .)
    *               reduce using rule 35 (expr -> expr * expr .)
    -               reduce using rule 35 (expr -> expr * expr .)
    +               reduce using rule 35 (expr -> expr * expr .)
    )               reduce using rule 35 (expr -> expr * expr .)


state 69

    (36) expr -> expr - expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 36 (expr -> expr - expr .)
    OU              reduce using rule 36 (expr -> expr - expr .)
    ET              reduce using rule 36 (expr -> expr - expr .)
    DIFFERENT       reduce using rule 36 (expr -> expr - expr .)
    EGAL            reduce using rule 36 (expr -> expr - expr .)
    SUPERIEUR_OU_EGAL reduce using rule 36 (expr -> expr - expr .)
    INFERIEUR_OU_EGAL reduce using rule 36 (expr -> expr - expr .)
    SUPERIEUR       reduce using rule 36 (expr -> expr - expr .)
    INFERIEUR       reduce using rule 36 (expr -> expr - expr .)
    -               reduce using rule 36 (expr -> expr - expr .)
    +               reduce using rule 36 (expr -> expr - expr .)
    )               reduce using rule 36 (expr -> expr - expr .)
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47


state 70

    (37) expr -> expr + expr .
    (23) expr -> expr . OU expr
    (24) expr -> expr . ET expr
    (25) expr -> expr . DIFFERENT expr
    (26) expr -> expr . EGAL expr
    (27) expr -> expr . SUPERIEUR_OU_EGAL expr
    (28) expr -> expr . INFERIEUR_OU_EGAL expr
    (29) expr -> expr . SUPERIEUR expr
    (30) expr -> expr . INFERIEUR expr
    (33) expr -> expr . % expr
    (34) expr -> expr . / expr
    (35) expr -> expr . * expr
    (36) expr -> expr . - expr
    (37) expr -> expr . + expr
    ;               reduce using rule 37 (expr -> expr + expr .)
    OU              reduce using rule 37 (expr -> expr + expr .)
    ET              reduce using rule 37 (expr -> expr + expr .)
    DIFFERENT       reduce using rule 37 (expr -> expr + expr .)
    EGAL            reduce using rule 37 (expr -> expr + expr .)
    SUPERIEUR_OU_EGAL reduce using rule 37 (expr -> expr + expr .)
    INFERIEUR_OU_EGAL reduce using rule 37 (expr -> expr + expr .)
    SUPERIEUR       reduce using rule 37 (expr -> expr + expr .)
    INFERIEUR       reduce using rule 37 (expr -> expr + expr .)
    -               reduce using rule 37 (expr -> expr + expr .)
    +               reduce using rule 37 (expr -> expr + expr .)
    )               reduce using rule 37 (expr -> expr + expr .)
    %               shift and go to state 45
    /               shift and go to state 46
    *               shift and go to state 47


state 71

    (17) instruction -> IDENTIFIANT = LIRE ( ) . ;
    ;               shift and go to state 77


state 72

    (32) expr -> ( expr ) .
    ;               reduce using rule 32 (expr -> ( expr ) .)
    OU              reduce using rule 32 (expr -> ( expr ) .)
    ET              reduce using rule 32 (expr -> ( expr ) .)
    DIFFERENT       reduce using rule 32 (expr -> ( expr ) .)
    EGAL            reduce using rule 32 (expr -> ( expr ) .)
    SUPERIEUR_OU_EGAL reduce using rule 32 (expr -> ( expr ) .)
    INFERIEUR_OU_EGAL reduce using rule 32 (expr -> ( expr ) .)
    SUPERIEUR       reduce using rule 32 (expr -> ( expr ) .)
    INFERIEUR       reduce using rule 32 (expr -> ( expr ) .)
    %               reduce using rule 32 (expr -> ( expr ) .)
    /               reduce using rule 32 (expr -> ( expr ) .)
    *               reduce using rule 32 (expr -> ( expr ) .)
    -               reduce using rule 32 (expr -> ( expr ) .)
    +               reduce using rule 32 (expr -> ( expr ) .)
    )               reduce using rule 32 (expr -> ( expr ) .)


state 73

    (8) instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .
    TYPE_BOOLEEN    reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    TYPE_ENTIER     reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    TANT_QUE        reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    SI              reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    $end            reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    }               reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)


state 74

    (12) instruction -> TANT_QUE ( expr ) { . listeInstructions }
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . TANT_QUE ( expr ) { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (15) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (16) instruction -> . SI ( expr ) { listeInstructions }
    (17) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (18) instruction -> . ecrire
    (19) ecrire -> . ECRIRE ( expr ) ;
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    TANT_QUE        shift and go to state 9
    SI              shift and go to state 10
    ECRIRE          shift and go to state 12

    listeInstructions              shift and go to state 78
    instruction                    shift and go to state 5
    ecrire                         shift and go to state 11

state 75

    (13) instruction -> SI ( expr ) { . listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> SI ( expr ) { . listeInstructions } SINON { listeInstructions }
    (15) instruction -> SI ( expr ) { . listeInstructions } SINON_SI
    (16) instruction -> SI ( expr ) { . listeInstructions }
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . TANT_QUE ( expr ) { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (15) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (16) instruction -> . SI ( expr ) { listeInstructions }
    (17) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (18) instruction -> . ecrire
    (19) ecrire -> . ECRIRE ( expr ) ;
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    TANT_QUE        shift and go to state 9
    SI              shift and go to state 10
    ECRIRE          shift and go to state 12

    listeInstructions              shift and go to state 79
    instruction                    shift and go to state 5
    ecrire                         shift and go to state 11

state 76

    (19) ecrire -> ECRIRE ( expr ) ; .
    TYPE_BOOLEEN    reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    TYPE_ENTIER     reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    IDENTIFIANT     reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    TANT_QUE        reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    SI              reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    ECRIRE          reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    $end            reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)
    }               reduce using rule 19 (ecrire -> ECRIRE ( expr ) ; .)


state 77

    (17) instruction -> IDENTIFIANT = LIRE ( ) ; .
    TYPE_BOOLEEN    reduce using rule 17 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    TYPE_ENTIER     reduce using rule 17 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    IDENTIFIANT     reduce using rule 17 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    TANT_QUE        reduce using rule 17 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    SI              reduce using rule 17 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    ECRIRE          reduce using rule 17 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    $end            reduce using rule 17 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    }               reduce using rule 17 (instruction -> IDENTIFIANT = LIRE ( ) ; .)


state 78

    (12) instruction -> TANT_QUE ( expr ) { listeInstructions . }
    }               shift and go to state 80


state 79

    (13) instruction -> SI ( expr ) { listeInstructions . } SINON_SI SINON { listeInstructions }
    (14) instruction -> SI ( expr ) { listeInstructions . } SINON { listeInstructions }
    (15) instruction -> SI ( expr ) { listeInstructions . } SINON_SI
    (16) instruction -> SI ( expr ) { listeInstructions . }
    }               shift and go to state 81


state 80

    (12) instruction -> TANT_QUE ( expr ) { listeInstructions } .
    TYPE_BOOLEEN    reduce using rule 12 (instruction -> TANT_QUE ( expr ) { listeInstructions } .)
    TYPE_ENTIER     reduce using rule 12 (instruction -> TANT_QUE ( expr ) { listeInstructions } .)
    IDENTIFIANT     reduce using rule 12 (instruction -> TANT_QUE ( expr ) { listeInstructions } .)
    TANT_QUE        reduce using rule 12 (instruction -> TANT_QUE ( expr ) { listeInstructions } .)
    SI              reduce using rule 12 (instruction -> TANT_QUE ( expr ) { listeInstructions } .)
    ECRIRE          reduce using rule 12 (instruction -> TANT_QUE ( expr ) { listeInstructions } .)
    $end            reduce using rule 12 (instruction -> TANT_QUE ( expr ) { listeInstructions } .)
    }               reduce using rule 12 (instruction -> TANT_QUE ( expr ) { listeInstructions } .)


state 81

    (13) instruction -> SI ( expr ) { listeInstructions } . SINON_SI SINON { listeInstructions }
    (14) instruction -> SI ( expr ) { listeInstructions } . SINON { listeInstructions }
    (15) instruction -> SI ( expr ) { listeInstructions } . SINON_SI
    (16) instruction -> SI ( expr ) { listeInstructions } .
    SINON_SI        shift and go to state 82
    SINON           shift and go to state 83
    TYPE_BOOLEEN    reduce using rule 16 (instruction -> SI ( expr ) { listeInstructions } .)
    TYPE_ENTIER     reduce using rule 16 (instruction -> SI ( expr ) { listeInstructions } .)
    IDENTIFIANT     reduce using rule 16 (instruction -> SI ( expr ) { listeInstructions } .)
    TANT_QUE        reduce using rule 16 (instruction -> SI ( expr ) { listeInstructions } .)
    SI              reduce using rule 16 (instruction -> SI ( expr ) { listeInstructions } .)
    ECRIRE          reduce using rule 16 (instruction -> SI ( expr ) { listeInstructions } .)
    $end            reduce using rule 16 (instruction -> SI ( expr ) { listeInstructions } .)
    }               reduce using rule 16 (instruction -> SI ( expr ) { listeInstructions } .)


state 82

    (13) instruction -> SI ( expr ) { listeInstructions } SINON_SI . SINON { listeInstructions }
    (15) instruction -> SI ( expr ) { listeInstructions } SINON_SI .
    SINON           shift and go to state 84
    TYPE_BOOLEEN    reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    TYPE_ENTIER     reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    IDENTIFIANT     reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    TANT_QUE        reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    SI              reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    ECRIRE          reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    $end            reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    }               reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)


state 83

    (14) instruction -> SI ( expr ) { listeInstructions } SINON . { listeInstructions }
    {               shift and go to state 85


state 84

    (13) instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON . { listeInstructions }
    {               shift and go to state 86


state 85

    (14) instruction -> SI ( expr ) { listeInstructions } SINON { . listeInstructions }
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . TANT_QUE ( expr ) { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (15) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (16) instruction -> . SI ( expr ) { listeInstructions }
    (17) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (18) instruction -> . ecrire
    (19) ecrire -> . ECRIRE ( expr ) ;
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    TANT_QUE        shift and go to state 9
    SI              shift and go to state 10
    ECRIRE          shift and go to state 12

    listeInstructions              shift and go to state 87
    instruction                    shift and go to state 5
    ecrire                         shift and go to state 11

state 86

    (13) instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { . listeInstructions }
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . TANT_QUE ( expr ) { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (15) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (16) instruction -> . SI ( expr ) { listeInstructions }
    (17) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (18) instruction -> . ecrire
    (19) ecrire -> . ECRIRE ( expr ) ;
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    TANT_QUE        shift and go to state 9
    SI              shift and go to state 10
    ECRIRE          shift and go to state 12

    listeInstructions              shift and go to state 88
    instruction                    shift and go to state 5
    ecrire                         shift and go to state 11

state 87

    (14) instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions . }
    }               shift and go to state 89


state 88

    (13) instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions . }
    }               shift and go to state 90


state 89

    (14) instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .
    TYPE_BOOLEEN    reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    TYPE_ENTIER     reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    IDENTIFIANT     reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    TANT_QUE        reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    SI              reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    ECRIRE          reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    $end            reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    }               reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)


state 90

    (13) instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .
    TYPE_BOOLEEN    reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    TYPE_ENTIER     reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    IDENTIFIANT     reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    TANT_QUE        reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    SI              reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    ECRIRE          reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    $end            reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    }               reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
