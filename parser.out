Grammar:

Rule 0     S' -> prog
Rule 1     prog -> listeSinonsi
Rule 2     prog -> listeInstructions
Rule 3     listeInstructions -> instruction listeInstructions
Rule 4     listeInstructions -> instruction
Rule 5     listeSinonsi -> SINON_SI listeSinonsi
Rule 6     listeSinonsi -> SINON_SI
Rule 7     instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ;
Rule 8     instruction -> TYPE_ENTIER IDENTIFIANT = expr ;
Rule 9     instruction -> IDENTIFIANT = expr ;
Rule 10    instruction -> TYPE_BOOLEEN IDENTIFIANT ;
Rule 11    instruction -> TYPE_ENTIER IDENTIFIANT ;
Rule 12    instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
Rule 13    instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions }
Rule 14    instruction -> SI ( expr ) { listeInstructions } SINON_SI
Rule 15    instruction -> SI ( expr ) { listeInstructions }
Rule 16    instruction -> IDENTIFIANT = LIRE ( ) ;
Rule 17    instruction -> ecrire
Rule 18    ecrire -> ECRIRE ( expr ) ;
Rule 19    expr -> FAUX
Rule 20    expr -> VRAI
Rule 21    expr -> NON expr  [precedence=right, level=2]
Rule 22    expr -> expr OU expr  [precedence=left, level=1]
Rule 23    expr -> expr ET expr  [precedence=left, level=1]
Rule 24    expr -> expr DIFFERENT expr  [precedence=left, level=3]
Rule 25    expr -> expr EGAL expr  [precedence=left, level=3]
Rule 26    expr -> expr SUPERIEUR_OU_EGAL expr  [precedence=left, level=3]
Rule 27    expr -> expr INFERIEUR_OU_EGAL expr  [precedence=left, level=3]
Rule 28    expr -> expr SUPERIEUR expr  [precedence=left, level=3]
Rule 29    expr -> expr INFERIEUR expr  [precedence=left, level=3]
Rule 30    expr -> ENTIER
Rule 31    expr -> ( expr )  [precedence=left, level=6]
Rule 32    expr -> expr % expr  [precedence=left, level=5]
Rule 33    expr -> expr / expr  [precedence=left, level=5]
Rule 34    expr -> expr * expr  [precedence=left, level=5]
Rule 35    expr -> expr - expr  [precedence=left, level=4]
Rule 36    expr -> expr + expr  [precedence=left, level=4]

Unused terminals:

    TANT_QUE
    >
    >=
    POINT_VIRGULE
    ==
    VIRGULE
    ACCOLADE_OUVRANTE
    PARENTHESE_FERMANTE
    ,
    RETOURNER
    <=
    PARENTHESE_OUVRANTE
    <
    ACCOLADE_FERMANTE
    !=

Terminals, with rules where they appear:

!=                   : 
%                    : 32
(                    : 12 13 14 15 16 18 31
)                    : 12 13 14 15 16 18 31
*                    : 34
+                    : 36
,                    : 
-                    : 35
/                    : 33
;                    : 7 8 9 10 11 16 18
<                    : 
<=                   : 
=                    : 7 8 9 16
==                   : 
>                    : 
>=                   : 
ACCOLADE_FERMANTE    : 
ACCOLADE_OUVRANTE    : 
DIFFERENT            : 24
ECRIRE               : 18
EGAL                 : 25
ENTIER               : 30
ET                   : 23
FAUX                 : 19
IDENTIFIANT          : 7 8 9 10 11 16
INFERIEUR            : 29
INFERIEUR_OU_EGAL    : 27
LIRE                 : 16
NON                  : 21
OU                   : 22
PARENTHESE_FERMANTE  : 
PARENTHESE_OUVRANTE  : 
POINT_VIRGULE        : 
RETOURNER            : 
SI                   : 12 13 14 15
SINON                : 12 13
SINON_SI             : 5 6 12 14
SUPERIEUR            : 28
SUPERIEUR_OU_EGAL    : 26
TANT_QUE             : 
TYPE_BOOLEEN         : 7 10
TYPE_ENTIER          : 8 11
VIRGULE              : 
VRAI                 : 20
error                : 
{                    : 12 12 13 13 14 15
}                    : 12 12 13 13 14 15

Nonterminals, with rules where they appear:

ecrire               : 17
expr                 : 7 8 9 12 13 14 15 18 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 31 32 32 33 33 34 34 35 35 36 36
instruction          : 3 4
listeInstructions    : 2 3 12 12 13 13 14 15
listeSinonsi         : 1 5
prog                 : 0


state 0

    (0) S' -> . prog
    (1) prog -> . listeSinonsi
    (2) prog -> . listeInstructions
    (5) listeSinonsi -> . SINON_SI listeSinonsi
    (6) listeSinonsi -> . SINON_SI
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (15) instruction -> . SI ( expr ) { listeInstructions }
    (16) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (17) instruction -> . ecrire
    (18) ecrire -> . ECRIRE ( expr ) ;
    SINON_SI        shift and go to state 4
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    SI              shift and go to state 9
    ECRIRE          shift and go to state 11

    prog                           shift and go to state 1
    listeSinonsi                   shift and go to state 2
    listeInstructions              shift and go to state 3
    instruction                    shift and go to state 5
    ecrire                         shift and go to state 10

state 1

    (0) S' -> prog .


state 2

    (1) prog -> listeSinonsi .
    $end            reduce using rule 1 (prog -> listeSinonsi .)


state 3

    (2) prog -> listeInstructions .
    $end            reduce using rule 2 (prog -> listeInstructions .)


state 4

    (5) listeSinonsi -> SINON_SI . listeSinonsi
    (6) listeSinonsi -> SINON_SI .
    (5) listeSinonsi -> . SINON_SI listeSinonsi
    (6) listeSinonsi -> . SINON_SI
    $end            reduce using rule 6 (listeSinonsi -> SINON_SI .)
    SINON_SI        shift and go to state 4

    listeSinonsi                   shift and go to state 12

state 5

    (3) listeInstructions -> instruction . listeInstructions
    (4) listeInstructions -> instruction .
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (15) instruction -> . SI ( expr ) { listeInstructions }
    (16) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (17) instruction -> . ecrire
    (18) ecrire -> . ECRIRE ( expr ) ;
    $end            reduce using rule 4 (listeInstructions -> instruction .)
    }               reduce using rule 4 (listeInstructions -> instruction .)
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    SI              shift and go to state 9
    ECRIRE          shift and go to state 11

    instruction                    shift and go to state 5
    listeInstructions              shift and go to state 13
    ecrire                         shift and go to state 10

state 6

    (7) instruction -> TYPE_BOOLEEN . IDENTIFIANT = expr ;
    (10) instruction -> TYPE_BOOLEEN . IDENTIFIANT ;
    IDENTIFIANT     shift and go to state 14


state 7

    (9) instruction -> IDENTIFIANT . = expr ;
    (16) instruction -> IDENTIFIANT . = LIRE ( ) ;
    =               shift and go to state 15


state 8

    (8) instruction -> TYPE_ENTIER . IDENTIFIANT = expr ;
    (11) instruction -> TYPE_ENTIER . IDENTIFIANT ;
    IDENTIFIANT     shift and go to state 16


state 9

    (12) instruction -> SI . ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> SI . ( expr ) { listeInstructions } SINON { listeInstructions }
    (14) instruction -> SI . ( expr ) { listeInstructions } SINON_SI
    (15) instruction -> SI . ( expr ) { listeInstructions }
    (               shift and go to state 17


state 10

    (17) instruction -> ecrire .
    TYPE_BOOLEEN    reduce using rule 17 (instruction -> ecrire .)
    TYPE_ENTIER     reduce using rule 17 (instruction -> ecrire .)
    IDENTIFIANT     reduce using rule 17 (instruction -> ecrire .)
    SI              reduce using rule 17 (instruction -> ecrire .)
    ECRIRE          reduce using rule 17 (instruction -> ecrire .)
    $end            reduce using rule 17 (instruction -> ecrire .)
    }               reduce using rule 17 (instruction -> ecrire .)


state 11

    (18) ecrire -> ECRIRE . ( expr ) ;
    (               shift and go to state 18


state 12

    (5) listeSinonsi -> SINON_SI listeSinonsi .
    $end            reduce using rule 5 (listeSinonsi -> SINON_SI listeSinonsi .)


state 13

    (3) listeInstructions -> instruction listeInstructions .
    $end            reduce using rule 3 (listeInstructions -> instruction listeInstructions .)
    }               reduce using rule 3 (listeInstructions -> instruction listeInstructions .)


state 14

    (7) instruction -> TYPE_BOOLEEN IDENTIFIANT . = expr ;
    (10) instruction -> TYPE_BOOLEEN IDENTIFIANT . ;
    =               shift and go to state 19
    ;               shift and go to state 20


state 15

    (9) instruction -> IDENTIFIANT = . expr ;
    (16) instruction -> IDENTIFIANT = . LIRE ( ) ;
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    LIRE            shift and go to state 22
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 21

state 16

    (8) instruction -> TYPE_ENTIER IDENTIFIANT . = expr ;
    (11) instruction -> TYPE_ENTIER IDENTIFIANT . ;
    =               shift and go to state 28
    ;               shift and go to state 29


state 17

    (12) instruction -> SI ( . expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> SI ( . expr ) { listeInstructions } SINON { listeInstructions }
    (14) instruction -> SI ( . expr ) { listeInstructions } SINON_SI
    (15) instruction -> SI ( . expr ) { listeInstructions }
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 30

state 18

    (18) ecrire -> ECRIRE ( . expr ) ;
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 31

state 19

    (7) instruction -> TYPE_BOOLEEN IDENTIFIANT = . expr ;
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 32

state 20

    (10) instruction -> TYPE_BOOLEEN IDENTIFIANT ; .
    TYPE_BOOLEEN    reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    TYPE_ENTIER     reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    IDENTIFIANT     reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    SI              reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    ECRIRE          reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    $end            reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)
    }               reduce using rule 10 (instruction -> TYPE_BOOLEEN IDENTIFIANT ; .)


state 21

    (9) instruction -> IDENTIFIANT = expr . ;
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               shift and go to state 33
    OU              shift and go to state 34
    ET              shift and go to state 35
    DIFFERENT       shift and go to state 36
    EGAL            shift and go to state 37
    SUPERIEUR_OU_EGAL shift and go to state 38
    INFERIEUR_OU_EGAL shift and go to state 39
    SUPERIEUR       shift and go to state 40
    INFERIEUR       shift and go to state 41
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 22

    (16) instruction -> IDENTIFIANT = LIRE . ( ) ;
    (               shift and go to state 47


state 23

    (31) expr -> ( . expr )
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 48

state 24

    (19) expr -> FAUX .
    ;               reduce using rule 19 (expr -> FAUX .)
    OU              reduce using rule 19 (expr -> FAUX .)
    ET              reduce using rule 19 (expr -> FAUX .)
    DIFFERENT       reduce using rule 19 (expr -> FAUX .)
    EGAL            reduce using rule 19 (expr -> FAUX .)
    SUPERIEUR_OU_EGAL reduce using rule 19 (expr -> FAUX .)
    INFERIEUR_OU_EGAL reduce using rule 19 (expr -> FAUX .)
    SUPERIEUR       reduce using rule 19 (expr -> FAUX .)
    INFERIEUR       reduce using rule 19 (expr -> FAUX .)
    %               reduce using rule 19 (expr -> FAUX .)
    /               reduce using rule 19 (expr -> FAUX .)
    *               reduce using rule 19 (expr -> FAUX .)
    -               reduce using rule 19 (expr -> FAUX .)
    +               reduce using rule 19 (expr -> FAUX .)
    )               reduce using rule 19 (expr -> FAUX .)


state 25

    (20) expr -> VRAI .
    ;               reduce using rule 20 (expr -> VRAI .)
    OU              reduce using rule 20 (expr -> VRAI .)
    ET              reduce using rule 20 (expr -> VRAI .)
    DIFFERENT       reduce using rule 20 (expr -> VRAI .)
    EGAL            reduce using rule 20 (expr -> VRAI .)
    SUPERIEUR_OU_EGAL reduce using rule 20 (expr -> VRAI .)
    INFERIEUR_OU_EGAL reduce using rule 20 (expr -> VRAI .)
    SUPERIEUR       reduce using rule 20 (expr -> VRAI .)
    INFERIEUR       reduce using rule 20 (expr -> VRAI .)
    %               reduce using rule 20 (expr -> VRAI .)
    /               reduce using rule 20 (expr -> VRAI .)
    *               reduce using rule 20 (expr -> VRAI .)
    -               reduce using rule 20 (expr -> VRAI .)
    +               reduce using rule 20 (expr -> VRAI .)
    )               reduce using rule 20 (expr -> VRAI .)


state 26

    (21) expr -> NON . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 49

state 27

    (30) expr -> ENTIER .
    ;               reduce using rule 30 (expr -> ENTIER .)
    OU              reduce using rule 30 (expr -> ENTIER .)
    ET              reduce using rule 30 (expr -> ENTIER .)
    DIFFERENT       reduce using rule 30 (expr -> ENTIER .)
    EGAL            reduce using rule 30 (expr -> ENTIER .)
    SUPERIEUR_OU_EGAL reduce using rule 30 (expr -> ENTIER .)
    INFERIEUR_OU_EGAL reduce using rule 30 (expr -> ENTIER .)
    SUPERIEUR       reduce using rule 30 (expr -> ENTIER .)
    INFERIEUR       reduce using rule 30 (expr -> ENTIER .)
    %               reduce using rule 30 (expr -> ENTIER .)
    /               reduce using rule 30 (expr -> ENTIER .)
    *               reduce using rule 30 (expr -> ENTIER .)
    -               reduce using rule 30 (expr -> ENTIER .)
    +               reduce using rule 30 (expr -> ENTIER .)
    )               reduce using rule 30 (expr -> ENTIER .)


state 28

    (8) instruction -> TYPE_ENTIER IDENTIFIANT = . expr ;
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 50

state 29

    (11) instruction -> TYPE_ENTIER IDENTIFIANT ; .
    TYPE_BOOLEEN    reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    TYPE_ENTIER     reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    IDENTIFIANT     reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    SI              reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    ECRIRE          reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    $end            reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)
    }               reduce using rule 11 (instruction -> TYPE_ENTIER IDENTIFIANT ; .)


state 30

    (12) instruction -> SI ( expr . ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> SI ( expr . ) { listeInstructions } SINON { listeInstructions }
    (14) instruction -> SI ( expr . ) { listeInstructions } SINON_SI
    (15) instruction -> SI ( expr . ) { listeInstructions }
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    )               shift and go to state 51
    OU              shift and go to state 34
    ET              shift and go to state 35
    DIFFERENT       shift and go to state 36
    EGAL            shift and go to state 37
    SUPERIEUR_OU_EGAL shift and go to state 38
    INFERIEUR_OU_EGAL shift and go to state 39
    SUPERIEUR       shift and go to state 40
    INFERIEUR       shift and go to state 41
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 31

    (18) ecrire -> ECRIRE ( expr . ) ;
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    )               shift and go to state 52
    OU              shift and go to state 34
    ET              shift and go to state 35
    DIFFERENT       shift and go to state 36
    EGAL            shift and go to state 37
    SUPERIEUR_OU_EGAL shift and go to state 38
    INFERIEUR_OU_EGAL shift and go to state 39
    SUPERIEUR       shift and go to state 40
    INFERIEUR       shift and go to state 41
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 32

    (7) instruction -> TYPE_BOOLEEN IDENTIFIANT = expr . ;
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               shift and go to state 53
    OU              shift and go to state 34
    ET              shift and go to state 35
    DIFFERENT       shift and go to state 36
    EGAL            shift and go to state 37
    SUPERIEUR_OU_EGAL shift and go to state 38
    INFERIEUR_OU_EGAL shift and go to state 39
    SUPERIEUR       shift and go to state 40
    INFERIEUR       shift and go to state 41
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 33

    (9) instruction -> IDENTIFIANT = expr ; .
    TYPE_BOOLEEN    reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    TYPE_ENTIER     reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    SI              reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    $end            reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)
    }               reduce using rule 9 (instruction -> IDENTIFIANT = expr ; .)


state 34

    (22) expr -> expr OU . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 54

state 35

    (23) expr -> expr ET . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 55

state 36

    (24) expr -> expr DIFFERENT . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 56

state 37

    (25) expr -> expr EGAL . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 57

state 38

    (26) expr -> expr SUPERIEUR_OU_EGAL . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 58

state 39

    (27) expr -> expr INFERIEUR_OU_EGAL . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 59

state 40

    (28) expr -> expr SUPERIEUR . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 60

state 41

    (29) expr -> expr INFERIEUR . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 61

state 42

    (32) expr -> expr % . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 62

state 43

    (33) expr -> expr / . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 63

state 44

    (34) expr -> expr * . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 64

state 45

    (35) expr -> expr - . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 65

state 46

    (36) expr -> expr + . expr
    (19) expr -> . FAUX
    (20) expr -> . VRAI
    (21) expr -> . NON expr
    (22) expr -> . expr OU expr
    (23) expr -> . expr ET expr
    (24) expr -> . expr DIFFERENT expr
    (25) expr -> . expr EGAL expr
    (26) expr -> . expr SUPERIEUR_OU_EGAL expr
    (27) expr -> . expr INFERIEUR_OU_EGAL expr
    (28) expr -> . expr SUPERIEUR expr
    (29) expr -> . expr INFERIEUR expr
    (30) expr -> . ENTIER
    (31) expr -> . ( expr )
    (32) expr -> . expr % expr
    (33) expr -> . expr / expr
    (34) expr -> . expr * expr
    (35) expr -> . expr - expr
    (36) expr -> . expr + expr
    FAUX            shift and go to state 24
    VRAI            shift and go to state 25
    NON             shift and go to state 26
    ENTIER          shift and go to state 27
    (               shift and go to state 23

    expr                           shift and go to state 66

state 47

    (16) instruction -> IDENTIFIANT = LIRE ( . ) ;
    )               shift and go to state 67


state 48

    (31) expr -> ( expr . )
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    )               shift and go to state 68
    OU              shift and go to state 34
    ET              shift and go to state 35
    DIFFERENT       shift and go to state 36
    EGAL            shift and go to state 37
    SUPERIEUR_OU_EGAL shift and go to state 38
    INFERIEUR_OU_EGAL shift and go to state 39
    SUPERIEUR       shift and go to state 40
    INFERIEUR       shift and go to state 41
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 49

    (21) expr -> NON expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 21 (expr -> NON expr .)
    OU              reduce using rule 21 (expr -> NON expr .)
    ET              reduce using rule 21 (expr -> NON expr .)
    )               reduce using rule 21 (expr -> NON expr .)
    DIFFERENT       shift and go to state 36
    EGAL            shift and go to state 37
    SUPERIEUR_OU_EGAL shift and go to state 38
    INFERIEUR_OU_EGAL shift and go to state 39
    SUPERIEUR       shift and go to state 40
    INFERIEUR       shift and go to state 41
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 50

    (8) instruction -> TYPE_ENTIER IDENTIFIANT = expr . ;
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               shift and go to state 69
    OU              shift and go to state 34
    ET              shift and go to state 35
    DIFFERENT       shift and go to state 36
    EGAL            shift and go to state 37
    SUPERIEUR_OU_EGAL shift and go to state 38
    INFERIEUR_OU_EGAL shift and go to state 39
    SUPERIEUR       shift and go to state 40
    INFERIEUR       shift and go to state 41
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 51

    (12) instruction -> SI ( expr ) . { listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> SI ( expr ) . { listeInstructions } SINON { listeInstructions }
    (14) instruction -> SI ( expr ) . { listeInstructions } SINON_SI
    (15) instruction -> SI ( expr ) . { listeInstructions }
    {               shift and go to state 70


state 52

    (18) ecrire -> ECRIRE ( expr ) . ;
    ;               shift and go to state 71


state 53

    (7) instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .
    TYPE_BOOLEEN    reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    TYPE_ENTIER     reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    SI              reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    $end            reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)
    }               reduce using rule 7 (instruction -> TYPE_BOOLEEN IDENTIFIANT = expr ; .)


state 54

    (22) expr -> expr OU expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 22 (expr -> expr OU expr .)
    OU              reduce using rule 22 (expr -> expr OU expr .)
    ET              reduce using rule 22 (expr -> expr OU expr .)
    )               reduce using rule 22 (expr -> expr OU expr .)
    DIFFERENT       shift and go to state 36
    EGAL            shift and go to state 37
    SUPERIEUR_OU_EGAL shift and go to state 38
    INFERIEUR_OU_EGAL shift and go to state 39
    SUPERIEUR       shift and go to state 40
    INFERIEUR       shift and go to state 41
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 55

    (23) expr -> expr ET expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 23 (expr -> expr ET expr .)
    OU              reduce using rule 23 (expr -> expr ET expr .)
    ET              reduce using rule 23 (expr -> expr ET expr .)
    )               reduce using rule 23 (expr -> expr ET expr .)
    DIFFERENT       shift and go to state 36
    EGAL            shift and go to state 37
    SUPERIEUR_OU_EGAL shift and go to state 38
    INFERIEUR_OU_EGAL shift and go to state 39
    SUPERIEUR       shift and go to state 40
    INFERIEUR       shift and go to state 41
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 56

    (24) expr -> expr DIFFERENT expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 24 (expr -> expr DIFFERENT expr .)
    OU              reduce using rule 24 (expr -> expr DIFFERENT expr .)
    ET              reduce using rule 24 (expr -> expr DIFFERENT expr .)
    DIFFERENT       reduce using rule 24 (expr -> expr DIFFERENT expr .)
    EGAL            reduce using rule 24 (expr -> expr DIFFERENT expr .)
    SUPERIEUR_OU_EGAL reduce using rule 24 (expr -> expr DIFFERENT expr .)
    INFERIEUR_OU_EGAL reduce using rule 24 (expr -> expr DIFFERENT expr .)
    SUPERIEUR       reduce using rule 24 (expr -> expr DIFFERENT expr .)
    INFERIEUR       reduce using rule 24 (expr -> expr DIFFERENT expr .)
    )               reduce using rule 24 (expr -> expr DIFFERENT expr .)
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 57

    (25) expr -> expr EGAL expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 25 (expr -> expr EGAL expr .)
    OU              reduce using rule 25 (expr -> expr EGAL expr .)
    ET              reduce using rule 25 (expr -> expr EGAL expr .)
    DIFFERENT       reduce using rule 25 (expr -> expr EGAL expr .)
    EGAL            reduce using rule 25 (expr -> expr EGAL expr .)
    SUPERIEUR_OU_EGAL reduce using rule 25 (expr -> expr EGAL expr .)
    INFERIEUR_OU_EGAL reduce using rule 25 (expr -> expr EGAL expr .)
    SUPERIEUR       reduce using rule 25 (expr -> expr EGAL expr .)
    INFERIEUR       reduce using rule 25 (expr -> expr EGAL expr .)
    )               reduce using rule 25 (expr -> expr EGAL expr .)
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 58

    (26) expr -> expr SUPERIEUR_OU_EGAL expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    OU              reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    ET              reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    DIFFERENT       reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    EGAL            reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    SUPERIEUR_OU_EGAL reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    INFERIEUR_OU_EGAL reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    SUPERIEUR       reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    INFERIEUR       reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    )               reduce using rule 26 (expr -> expr SUPERIEUR_OU_EGAL expr .)
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 59

    (27) expr -> expr INFERIEUR_OU_EGAL expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    OU              reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    ET              reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    DIFFERENT       reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    EGAL            reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    SUPERIEUR_OU_EGAL reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    INFERIEUR_OU_EGAL reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    SUPERIEUR       reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    INFERIEUR       reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    )               reduce using rule 27 (expr -> expr INFERIEUR_OU_EGAL expr .)
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 60

    (28) expr -> expr SUPERIEUR expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    OU              reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    ET              reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    DIFFERENT       reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    EGAL            reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    SUPERIEUR_OU_EGAL reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    INFERIEUR_OU_EGAL reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    SUPERIEUR       reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    INFERIEUR       reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    )               reduce using rule 28 (expr -> expr SUPERIEUR expr .)
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 61

    (29) expr -> expr INFERIEUR expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 29 (expr -> expr INFERIEUR expr .)
    OU              reduce using rule 29 (expr -> expr INFERIEUR expr .)
    ET              reduce using rule 29 (expr -> expr INFERIEUR expr .)
    DIFFERENT       reduce using rule 29 (expr -> expr INFERIEUR expr .)
    EGAL            reduce using rule 29 (expr -> expr INFERIEUR expr .)
    SUPERIEUR_OU_EGAL reduce using rule 29 (expr -> expr INFERIEUR expr .)
    INFERIEUR_OU_EGAL reduce using rule 29 (expr -> expr INFERIEUR expr .)
    SUPERIEUR       reduce using rule 29 (expr -> expr INFERIEUR expr .)
    INFERIEUR       reduce using rule 29 (expr -> expr INFERIEUR expr .)
    )               reduce using rule 29 (expr -> expr INFERIEUR expr .)
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 62

    (32) expr -> expr % expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 32 (expr -> expr % expr .)
    OU              reduce using rule 32 (expr -> expr % expr .)
    ET              reduce using rule 32 (expr -> expr % expr .)
    DIFFERENT       reduce using rule 32 (expr -> expr % expr .)
    EGAL            reduce using rule 32 (expr -> expr % expr .)
    SUPERIEUR_OU_EGAL reduce using rule 32 (expr -> expr % expr .)
    INFERIEUR_OU_EGAL reduce using rule 32 (expr -> expr % expr .)
    SUPERIEUR       reduce using rule 32 (expr -> expr % expr .)
    INFERIEUR       reduce using rule 32 (expr -> expr % expr .)
    %               reduce using rule 32 (expr -> expr % expr .)
    /               reduce using rule 32 (expr -> expr % expr .)
    *               reduce using rule 32 (expr -> expr % expr .)
    -               reduce using rule 32 (expr -> expr % expr .)
    +               reduce using rule 32 (expr -> expr % expr .)
    )               reduce using rule 32 (expr -> expr % expr .)


state 63

    (33) expr -> expr / expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 33 (expr -> expr / expr .)
    OU              reduce using rule 33 (expr -> expr / expr .)
    ET              reduce using rule 33 (expr -> expr / expr .)
    DIFFERENT       reduce using rule 33 (expr -> expr / expr .)
    EGAL            reduce using rule 33 (expr -> expr / expr .)
    SUPERIEUR_OU_EGAL reduce using rule 33 (expr -> expr / expr .)
    INFERIEUR_OU_EGAL reduce using rule 33 (expr -> expr / expr .)
    SUPERIEUR       reduce using rule 33 (expr -> expr / expr .)
    INFERIEUR       reduce using rule 33 (expr -> expr / expr .)
    %               reduce using rule 33 (expr -> expr / expr .)
    /               reduce using rule 33 (expr -> expr / expr .)
    *               reduce using rule 33 (expr -> expr / expr .)
    -               reduce using rule 33 (expr -> expr / expr .)
    +               reduce using rule 33 (expr -> expr / expr .)
    )               reduce using rule 33 (expr -> expr / expr .)


state 64

    (34) expr -> expr * expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 34 (expr -> expr * expr .)
    OU              reduce using rule 34 (expr -> expr * expr .)
    ET              reduce using rule 34 (expr -> expr * expr .)
    DIFFERENT       reduce using rule 34 (expr -> expr * expr .)
    EGAL            reduce using rule 34 (expr -> expr * expr .)
    SUPERIEUR_OU_EGAL reduce using rule 34 (expr -> expr * expr .)
    INFERIEUR_OU_EGAL reduce using rule 34 (expr -> expr * expr .)
    SUPERIEUR       reduce using rule 34 (expr -> expr * expr .)
    INFERIEUR       reduce using rule 34 (expr -> expr * expr .)
    %               reduce using rule 34 (expr -> expr * expr .)
    /               reduce using rule 34 (expr -> expr * expr .)
    *               reduce using rule 34 (expr -> expr * expr .)
    -               reduce using rule 34 (expr -> expr * expr .)
    +               reduce using rule 34 (expr -> expr * expr .)
    )               reduce using rule 34 (expr -> expr * expr .)


state 65

    (35) expr -> expr - expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 35 (expr -> expr - expr .)
    OU              reduce using rule 35 (expr -> expr - expr .)
    ET              reduce using rule 35 (expr -> expr - expr .)
    DIFFERENT       reduce using rule 35 (expr -> expr - expr .)
    EGAL            reduce using rule 35 (expr -> expr - expr .)
    SUPERIEUR_OU_EGAL reduce using rule 35 (expr -> expr - expr .)
    INFERIEUR_OU_EGAL reduce using rule 35 (expr -> expr - expr .)
    SUPERIEUR       reduce using rule 35 (expr -> expr - expr .)
    INFERIEUR       reduce using rule 35 (expr -> expr - expr .)
    -               reduce using rule 35 (expr -> expr - expr .)
    +               reduce using rule 35 (expr -> expr - expr .)
    )               reduce using rule 35 (expr -> expr - expr .)
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44


state 66

    (36) expr -> expr + expr .
    (22) expr -> expr . OU expr
    (23) expr -> expr . ET expr
    (24) expr -> expr . DIFFERENT expr
    (25) expr -> expr . EGAL expr
    (26) expr -> expr . SUPERIEUR_OU_EGAL expr
    (27) expr -> expr . INFERIEUR_OU_EGAL expr
    (28) expr -> expr . SUPERIEUR expr
    (29) expr -> expr . INFERIEUR expr
    (32) expr -> expr . % expr
    (33) expr -> expr . / expr
    (34) expr -> expr . * expr
    (35) expr -> expr . - expr
    (36) expr -> expr . + expr
    ;               reduce using rule 36 (expr -> expr + expr .)
    OU              reduce using rule 36 (expr -> expr + expr .)
    ET              reduce using rule 36 (expr -> expr + expr .)
    DIFFERENT       reduce using rule 36 (expr -> expr + expr .)
    EGAL            reduce using rule 36 (expr -> expr + expr .)
    SUPERIEUR_OU_EGAL reduce using rule 36 (expr -> expr + expr .)
    INFERIEUR_OU_EGAL reduce using rule 36 (expr -> expr + expr .)
    SUPERIEUR       reduce using rule 36 (expr -> expr + expr .)
    INFERIEUR       reduce using rule 36 (expr -> expr + expr .)
    -               reduce using rule 36 (expr -> expr + expr .)
    +               reduce using rule 36 (expr -> expr + expr .)
    )               reduce using rule 36 (expr -> expr + expr .)
    %               shift and go to state 42
    /               shift and go to state 43
    *               shift and go to state 44


state 67

    (16) instruction -> IDENTIFIANT = LIRE ( ) . ;
    ;               shift and go to state 72


state 68

    (31) expr -> ( expr ) .
    ;               reduce using rule 31 (expr -> ( expr ) .)
    OU              reduce using rule 31 (expr -> ( expr ) .)
    ET              reduce using rule 31 (expr -> ( expr ) .)
    DIFFERENT       reduce using rule 31 (expr -> ( expr ) .)
    EGAL            reduce using rule 31 (expr -> ( expr ) .)
    SUPERIEUR_OU_EGAL reduce using rule 31 (expr -> ( expr ) .)
    INFERIEUR_OU_EGAL reduce using rule 31 (expr -> ( expr ) .)
    SUPERIEUR       reduce using rule 31 (expr -> ( expr ) .)
    INFERIEUR       reduce using rule 31 (expr -> ( expr ) .)
    %               reduce using rule 31 (expr -> ( expr ) .)
    /               reduce using rule 31 (expr -> ( expr ) .)
    *               reduce using rule 31 (expr -> ( expr ) .)
    -               reduce using rule 31 (expr -> ( expr ) .)
    +               reduce using rule 31 (expr -> ( expr ) .)
    )               reduce using rule 31 (expr -> ( expr ) .)


state 69

    (8) instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .
    TYPE_BOOLEEN    reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    TYPE_ENTIER     reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    IDENTIFIANT     reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    SI              reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    $end            reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)
    }               reduce using rule 8 (instruction -> TYPE_ENTIER IDENTIFIANT = expr ; .)


state 70

    (12) instruction -> SI ( expr ) { . listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> SI ( expr ) { . listeInstructions } SINON { listeInstructions }
    (14) instruction -> SI ( expr ) { . listeInstructions } SINON_SI
    (15) instruction -> SI ( expr ) { . listeInstructions }
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (15) instruction -> . SI ( expr ) { listeInstructions }
    (16) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (17) instruction -> . ecrire
    (18) ecrire -> . ECRIRE ( expr ) ;
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    SI              shift and go to state 9
    ECRIRE          shift and go to state 11

    listeInstructions              shift and go to state 73
    instruction                    shift and go to state 5
    ecrire                         shift and go to state 10

state 71

    (18) ecrire -> ECRIRE ( expr ) ; .
    TYPE_BOOLEEN    reduce using rule 18 (ecrire -> ECRIRE ( expr ) ; .)
    TYPE_ENTIER     reduce using rule 18 (ecrire -> ECRIRE ( expr ) ; .)
    IDENTIFIANT     reduce using rule 18 (ecrire -> ECRIRE ( expr ) ; .)
    SI              reduce using rule 18 (ecrire -> ECRIRE ( expr ) ; .)
    ECRIRE          reduce using rule 18 (ecrire -> ECRIRE ( expr ) ; .)
    $end            reduce using rule 18 (ecrire -> ECRIRE ( expr ) ; .)
    }               reduce using rule 18 (ecrire -> ECRIRE ( expr ) ; .)


state 72

    (16) instruction -> IDENTIFIANT = LIRE ( ) ; .
    TYPE_BOOLEEN    reduce using rule 16 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    TYPE_ENTIER     reduce using rule 16 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    IDENTIFIANT     reduce using rule 16 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    SI              reduce using rule 16 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    ECRIRE          reduce using rule 16 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    $end            reduce using rule 16 (instruction -> IDENTIFIANT = LIRE ( ) ; .)
    }               reduce using rule 16 (instruction -> IDENTIFIANT = LIRE ( ) ; .)


state 73

    (12) instruction -> SI ( expr ) { listeInstructions . } SINON_SI SINON { listeInstructions }
    (13) instruction -> SI ( expr ) { listeInstructions . } SINON { listeInstructions }
    (14) instruction -> SI ( expr ) { listeInstructions . } SINON_SI
    (15) instruction -> SI ( expr ) { listeInstructions . }
    }               shift and go to state 74


state 74

    (12) instruction -> SI ( expr ) { listeInstructions } . SINON_SI SINON { listeInstructions }
    (13) instruction -> SI ( expr ) { listeInstructions } . SINON { listeInstructions }
    (14) instruction -> SI ( expr ) { listeInstructions } . SINON_SI
    (15) instruction -> SI ( expr ) { listeInstructions } .
    SINON_SI        shift and go to state 75
    SINON           shift and go to state 76
    TYPE_BOOLEEN    reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } .)
    TYPE_ENTIER     reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } .)
    IDENTIFIANT     reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } .)
    SI              reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } .)
    ECRIRE          reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } .)
    $end            reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } .)
    }               reduce using rule 15 (instruction -> SI ( expr ) { listeInstructions } .)


state 75

    (12) instruction -> SI ( expr ) { listeInstructions } SINON_SI . SINON { listeInstructions }
    (14) instruction -> SI ( expr ) { listeInstructions } SINON_SI .
    SINON           shift and go to state 77
    TYPE_BOOLEEN    reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    TYPE_ENTIER     reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    IDENTIFIANT     reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    SI              reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    ECRIRE          reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    $end            reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)
    }               reduce using rule 14 (instruction -> SI ( expr ) { listeInstructions } SINON_SI .)


state 76

    (13) instruction -> SI ( expr ) { listeInstructions } SINON . { listeInstructions }
    {               shift and go to state 78


state 77

    (12) instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON . { listeInstructions }
    {               shift and go to state 79


state 78

    (13) instruction -> SI ( expr ) { listeInstructions } SINON { . listeInstructions }
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (15) instruction -> . SI ( expr ) { listeInstructions }
    (16) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (17) instruction -> . ecrire
    (18) ecrire -> . ECRIRE ( expr ) ;
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    SI              shift and go to state 9
    ECRIRE          shift and go to state 11

    listeInstructions              shift and go to state 80
    instruction                    shift and go to state 5
    ecrire                         shift and go to state 10

state 79

    (12) instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { . listeInstructions }
    (3) listeInstructions -> . instruction listeInstructions
    (4) listeInstructions -> . instruction
    (7) instruction -> . TYPE_BOOLEEN IDENTIFIANT = expr ;
    (8) instruction -> . TYPE_ENTIER IDENTIFIANT = expr ;
    (9) instruction -> . IDENTIFIANT = expr ;
    (10) instruction -> . TYPE_BOOLEEN IDENTIFIANT ;
    (11) instruction -> . TYPE_ENTIER IDENTIFIANT ;
    (12) instruction -> . SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions }
    (13) instruction -> . SI ( expr ) { listeInstructions } SINON { listeInstructions }
    (14) instruction -> . SI ( expr ) { listeInstructions } SINON_SI
    (15) instruction -> . SI ( expr ) { listeInstructions }
    (16) instruction -> . IDENTIFIANT = LIRE ( ) ;
    (17) instruction -> . ecrire
    (18) ecrire -> . ECRIRE ( expr ) ;
    TYPE_BOOLEEN    shift and go to state 6
    TYPE_ENTIER     shift and go to state 8
    IDENTIFIANT     shift and go to state 7
    SI              shift and go to state 9
    ECRIRE          shift and go to state 11

    listeInstructions              shift and go to state 81
    instruction                    shift and go to state 5
    ecrire                         shift and go to state 10

state 80

    (13) instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions . }
    }               shift and go to state 82


state 81

    (12) instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions . }
    }               shift and go to state 83


state 82

    (13) instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .
    TYPE_BOOLEEN    reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    TYPE_ENTIER     reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    IDENTIFIANT     reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    SI              reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    ECRIRE          reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    $end            reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)
    }               reduce using rule 13 (instruction -> SI ( expr ) { listeInstructions } SINON { listeInstructions } .)


state 83

    (12) instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .
    TYPE_BOOLEEN    reduce using rule 12 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    TYPE_ENTIER     reduce using rule 12 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    IDENTIFIANT     reduce using rule 12 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    SI              reduce using rule 12 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    ECRIRE          reduce using rule 12 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    $end            reduce using rule 12 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
    }               reduce using rule 12 (instruction -> SI ( expr ) { listeInstructions } SINON_SI SINON { listeInstructions } .)
